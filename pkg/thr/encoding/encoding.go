package encoding

import "encoding/hex"

// standard sysex start and end bytes
const msgStart = 0xf0
const msgEnd = 0xf7

// next will take a buffer of bytes and return the next complete sysex message, as well as the
// remaining buffer that was not read.
func Next(buff []byte) (*Message, []byte) {

	msg := &Message{}

	// scan through the buffer looking for the start of the message
	var i int
	for i = 0; i < len(buff); i++ {
		if buff[i] != msgStart {
			continue
		} else {
			break
		}
	}
	// discard all read bytes from the buffer before start byte
	if len(buff) > i {
		buff = buff[i+1:]
	} else {
		return nil, []byte{}
	}

	// the manufacturer code should be 3 bytes
	if len(buff) > 3 {
		// check for incorrect manufacturers code
		if buff[0] != 0x00 && buff[1] != 0x01 && buff[2] != 0x0c {
			return nil, buff
		}
		copy(msg.ManufacturerCode[:], buff[:3])
		buff = buff[3:]
	}

	// there should be 8 bytes of data leading up to the payload. The last byte
	// defines how big the payload will be.
	if len(buff) > 8 {
		copy(msg.Preamble[:], buff[:3])
		msg.MessageType = buff[3]
		msg.SequenceNum = buff[4]
		copy(msg.Reserved1[:], buff[5:6])
		msg.PayloadType = buff[7]

		buff = buff[8:]
	}

	switch msg.PayloadType {
	// 0x03 denotes a short message (12 bytes) + msgEnd
	case 0x03:
		if len(buff) < 12 {
			// not enough data in buffer
			return nil, buff
		}
		msg.Payload = buff[:12]
		buff = buff[12:]

	// consider all others (e.g. 0x07, 0x08, 0x0b) 16 bytes
	default:
		if len(buff) < 16 {
			// not enough data in buffer
			return nil, buff
		}
		msg.Payload = buff[:16]
		buff = buff[16:]
	}

	if len(buff) == 0 || buff[0] != msgEnd {
		// end byte was not at expected position
		return nil, buff
	}
	buff = buff[1:]

	return msg, buff
}

type Message struct {
	ManufacturerCode [3]byte
	Preamble         [3]byte
	MessageType      byte
	SequenceNum      byte
	Reserved1        [2]byte
	PayloadType      byte
	Payload          []byte
}

func (m *Message) Encode() []byte {
	// standard sysex start
	buff := []byte{msgStart}
	// The manufacturer's code uses the extended 3 byte format.
	buff = append(buff, m.ManufacturerCode[:]...)
	// All messages have this same preamble - is it a device code or something?
	buff = append(buff, m.Preamble[:]...)
	// Commands seems to be prefixed with 00 or 01. see msgType above
	buff = append(buff, m.MessageType)
	// There is a 1 byte sequence that rolls over when at the maximum value
	buff = append(buff, m.SequenceNum)
	// unused(?) the second byte is set to 0x01 in events generated by the amp.
	buff = append(buff, m.Reserved1[:]...)
	// the payload seems to have a type that dictates its length and probably other stuff.
	buff = append(buff, m.PayloadType)
	// The payload is arbitrary bytes
	buff = append(buff, m.Payload...)
	// standard sysex end
	buff = append(buff, msgEnd)
	return buff
}

func (m *Message) Hex() string {
	return hex.EncodeToString(m.Encode())
}
