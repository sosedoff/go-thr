package amp

import (
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"github.com/rakyll/portmidi"
	"go.uber.org/zap"
)

// standard sysex start and end bytes
const msgStart = 0xf0
const msgEnd = 0xf7

// msg type one seems to be used predominantly for "getter" type commands while
// msg type two seems to be used for "setter" commands. However this doesn't seem to be the actual
// system because sometimes things I would expect to use 00 use 01.
const msgTypeOne = 0x00
const msgTypeTwo = 0x01

type CommandSet []Command

type Command interface {
	Bytes(seqNum uint32) []byte
}

type RawCommmand struct {
	Data []byte
}

func (c *RawCommmand) Bytes(seqNum uint32) []byte {
	return c.Data
}

type THRCommand struct {
	Type    byte
	Payload []byte
}

func (c *THRCommand) Bytes(seqNum uint32) []byte {
	// standard sysex start
	buff := []byte{msgStart}
	// The manufacturer's code uses the extended 3 byte format.
	buff = append(buff, yamahaManufacturerCode()...)
	// All messages have this same preamble - is it a device code or something?
	buff = append(buff, preamble()...)
	// Commands seems to be prefixed with 00 or 01. see msgType above
	buff = append(buff, c.Type)
	// There is a 1 byte sequence that rolls over when at the maximum value
	buff = append(buff, sequenceNumber(seqNum))
	// unused(?) the second byte is set to 0x01 in events generated by the amp.
	buff = append(buff, 0x00, 0x00)
	// The payload is arbitrary bytes
	buff = append(buff, c.Payload...)
	// standard sysex end
	buff = append(buff, msgEnd)
	return buff
}

func NewSession(out *portmidi.Stream, logger *zap.Logger) *Session {
	return &Session{out: out, logger: logger}
}

// Session manages sequence numbers
type Session struct {
	sequenceNum uint32
	out         *portmidi.Stream
	logger      *zap.Logger
}

func (s *Session) Send(cmds CommandSet) error {
	for _, cmd := range cmds {
		data := cmd.Bytes(s.sequenceNum)
		if err := s.out.WriteSysExBytes(portmidi.Time(), data); err != nil {
			return err
		}
		if s.logger != nil {
			s.logger.Debug("sent", zap.String("data", hex.EncodeToString(data)))
		}
		s.sequenceNum++

	}
	return nil
}

func yamahaManufacturerCode() []byte {
	// manufacturer ID 0x00 indicates a 3 byte ID
	return []byte{0x00, 0x01, 0x0C}
}

// mystery stuff that gets send with every command
func preamble() []byte {
	return []byte{0x22, 0x02, 0x4d}
}

func sequenceNumber(seqNum uint32) byte {
	// sequence number should only be 1 byte so it needs to roll over at 127
	if seqNum > 127 {
		seqNum = seqNum - (127 * (seqNum / 127))
	}
	return singleByteInt(int8(seqNum))
}

func singleByteInt(num int8) byte {
	bs := &bytes.Buffer{}
	binary.Write(bs, binary.LittleEndian, num)
	return bs.Bytes()[0]
}
